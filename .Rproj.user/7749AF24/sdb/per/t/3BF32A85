{
    "contents" : "---\ntitle: \"ggvis and shinyapps\"\nauthor: \"Ted Laderas\"\ndate: \"April 29, 2015\"\noutput: slidy_presentation\n---\n## ggvis\n\nAnother Hadley Wickham/RStudio joint.\n\nggvis is for interactive graphics.\n\n- compatible with dplyr\n- properties can be adjusted on the fly with inputs\n- tooltips can show underlying data\n- built on top of Vega (grammar of graphics) and \n- D3 (JavaScript Library for visualization/interactive data)\n- Bleeding edge (interfaces may change from version to version)\n\nHere is a great ggvis tutorial from [O'Reilly/Rstudio](http://cdn.oreillystatic.com/en/assets/1/event/120/ggvis_%20Interactive,%20intuitive%20graphics%20in%20R%20Presentation.pdf) - some of these slides are taken from this.\n\n```{r,eval=TRUE,echo=FALSE,warning=FALSE}\nlibrary(ggplot2)\nlibrary(ggvis)\nlibrary(dplyr)\n```\n\n## ggplot2 versus ggvis\n\nThese will produce the same plots:\n\n```{r,eval=FALSE}\nggplot(iris) + geom_point(aes(x=Sepal.Width, y=Sepal.Length, colour =Species)) +\n  scale_color_manual(values= c(\"red\", \"green\", \"blue\"))  \n```\n\n```{r,eval=FALSE}\niris %>% ggvis() %>% layer_points(x=~Sepal.Width, y=~Sepal.Length, \n                                  fill=~Species) %>%\n  scale_ordinal(property=\"fill\", range = c(\"red\", \"green\", \"blue\"))\n```\n\n## ggplot2 versus ggvis\n\n```{r}\nggplot(iris) + geom_point(aes(x=Sepal.Width, y=Sepal.Length, colour =Species)) +\n  scale_color_manual(values= c(\"red\", \"green\", \"blue\"))  \n```\n\n```{r}\niris %>% ggvis() %>% layer_points(x=~Sepal.Width, y=~Sepal.Length, \n                                  fill=~Species) %>%\n  scale_ordinal(property=\"fill\", range = c(\"red\", \"green\", \"blue\"))\n```\n\n## Coming from ggplot2? We've got you covered.\n\nHere is a rough mapping of ggplot2 concepts to ggvis.\n\n```{r table2, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}\ntab <- \n\"|*ggplot2*   | maps to      | *ggvis* \n|:------------|:------------:|:----------------\n|+            | ->           | %>%\n|variable     | ->           | ~variable\n|layer, geom  | ->           | layer function\n|stat         | ->           | compute function\n|aes()        | ->           | props()\n|ggplot()     | ->           | ggvis()\"\ncat(tab)\n```\n\n## Mapping the data (x and y)\n\n![mapping data](images/ggvis-mapping.png)\n\n## Mapping the data (shape and fill)\n\n![mapping data 2](images/ggvis-mapping2.png)\n\n## The %>% (Pipe)\n\nThe fact that ggvis uses the pipe (%>%) is super useful. It allows you to mix dplyr commands in with ggvis layers, allowing for much more flexibility than ggplot. This becomes especially useful in filtering and selecting data.\n\nNote that it can become confusing, since dplyr refers to the variables as is (such as Sepal.Length), while you need a tilde (~) to refer to them in ggvis (~Sepal.Length).\n\n```{r}\niris %>% mutate(sepalRatio = Sepal.Width / Sepal.Length, \n                petalRatio = Petal.Width / Petal.Length) %>%\n  ggvis() %>% layer_points(x=~sepalRatio, y=~petalRatio, fill=~Species)\n```\n\n## What properties exist?\n\nLook at the documentation for ?marks. Here are a few. Not all of these properties exist for every layer, so check the documentation for your layer of interest.\n\n- x (x coordinate)\n- y (y coordinate)\n- width (width of mark)\n- stroke (stoke color (outline) of mark)\n- fill\n- opacity\n- size\n\n## := (Unscaled) versus = (Scaled)\n\nWhen you map a property to a variable, you have the option of being scaled (=) versus unscaled (:=). \n\nScaled properties are mapped to graphical concepts. For example, if your variable ranges from 10-30 and you map it to the x property. You can change this behavior using the appropriate scale() function. \n\nTwo scale functions you'll probably use the most are scale_numeric() (for continuous data) and scale_nominal() (for categorical data)\n\n```{r}\niris %>% ggvis() %>% layer_points(x=~Sepal.Width, y=~Sepal.Length, \n                                  fill=~Species) %>%\n  scale_numeric(\"x\", domain = c(2,5))\n```\n\n## Unscaled Properties\n\nUnscaled properties are used as raw values. If you have a unique identifier for each row in your data and you need to use this identifier to refer to another table, you would use it as an unscaled property. This is useful when adding tooltips to data. I'll show this in the demo.\n\nAnother reason to use unscaled properties is if the data directly maps to a concept, such as color. For example, say the iris data set had a color column that mapped to RGB values, you could directly use these values as an unscaled property.\n\nMore information at [http://ggvis.rstudio.com/properties-scales.html](http://ggvis.rstudio.com/properties-scales.html)\n\n## Going from geoms to layers\n\nThere is a somewhat comprehensive mapping here:\n\n[http://ggvis.rstudio.com/layers.html](http://ggvis.rstudio.com/layers.html)\n\n## compute functions\n\nggvis provides some inline compute functions that will compute properties of the data. I don't really have time to talk about these, but they exist, and essentially you pipe the data through them.\n\n- compute_smooth() - layer_smooth() uses this.\n- compute_density()\n- compute_model_predictions()\n- compute_bin()\n\n## group_by\n\n![group_by()](images/group_by.png)\n\n## Interactive inputs to ggvis\n\nggvis can run standalone, or as part of shiny. For right now, we'll run it standalone, which means it will run in Rstudio. So we can use the various input functions to ggvis to modify our plots.\n\n- input_slider(): a slider\n- input_checkbox(): a check-box\n- input_checkboxgroup(): a group of check boxes\n- input_numeric(): a spin box\n- input_radiobuttons(): pick one from a set options\n- input_select(): create a drop-down text box\n- input_text(): arbitrary text input\n\n## Sliders\n```{r}\niris %>% ggvis(x=~Sepal.Width, y=~Sepal.Length) %>% group_by(Species) %>%\n  layer_smooths(span = input_slider(min = 0.5, max = 1, value =.5),se = TRUE) %>% \n  layer_points(fill=~Species) \n```      \n\n## Checkbox in Action\n```{r}\nmodel_type <- input_checkbox(label = \"Use flexible curve\",\n  map = function(val) if(val) \"loess\" else \"lm\")\n\niris %>% ggvis(x=~Sepal.Width, y=~Sepal.Length) %>% group_by(Species) %>%\n  layer_points(fill=~Species) %>%\n  layer_model_predictions(se = TRUE, model=model_type) \n```\n  \n## Keyboard Interactivity\n```{r}\nkeys_s <- left_right(10, 1000, step = 50)\niris %>% ggvis(~Sepal.Width, ~Sepal.Length, size := keys_s, opacity := 0.5) %>% layer_points()\n```\n\n## Limits to Interactivity\n\nNot everything is interactive. We can mostly only modify properties of the data visualization, but changing the property mapping dynamically requires some trickery. For example, if we had select boxes selecting what's being mapped on the x and y axis.\n\nLook at the code for the [movie explorer](https://github.com/rstudio/shiny-examples/tree/master/051-movie-explorer) for an example of how to do this.\n\nFor modifying the data, I use dplyr to filter the data, or make the data a reactive expression. To do this, you have to embed your plot into a Shiny app.\n\n## Running in Shiny\n\nInstead of using the input functions such as input_slider(), you will simply use widgets that are specified in ui.R.\n\nTwo ways of doing so. You can just pipe the expression into bind_shiny() like this\n\n```{r, eval=FALSE}\nkeys_s <- left_right(10, 1000, step = 50)\niris %>% ggvis(~Sepal.Width, ~Sepal.Length, size := keys_s, opacity := 0.5) %>% layer_points() %>% bind_shiny(\"ggvisPlot1\")\n```\n\nYou can also embed your ggvis plot into a Shiny reactive expression to get it to display. Then we pipe that reactive expression into bind_shiny()\n\n```{r, eval=FALSE}\nggvisPlot <- reactive({\n  keys_s <- left_right(10, 1000, step = 50)\n  iris %>% ggvis(~Sepal.Width, ~Sepal.Length, \n                 size := keys_s, opacity := 0.5) %>% \n    layer_points()\n})\n\nggvisPlot %>% bind_shiny(\"ggvisPlot1\")\n```\n\nAfter you do this, you can embed the plot into ui.R with the ggvisOutput() function.\n\n```{r, eval=FALSE}\nggvisOutput(\"ggvisPlot1\")\n```\n\n## saving your ggvis figures\n\n![ggvis-save](images/saving-plots.png)\n\n## Deploying your shiny apps\n\nYou can deploy your apps to a standalone R-server, or to shinyapps.io. Ask Ryan about setting up a Shiny server instance. (Hopefully coming soon to a ohsu server near you.)\n\nshinyapps.io provides you with 25 compute hours for 5 applications for free. You'll need to download the shinyapps package, register on shinyapps.io, and obtain a key (allows Rstudio to directly deploy). \n\nThen you can simply deploy your app with shinyapps::deployApp(). \n\n## Thanks!\n\n- Janice\n- Rstudio/Hadley Wickham\n\n## Coming Soon\n\nShiny/ggvis hackathon!\n\n- Teams?\n- Time? \n- What data?\n- What kinds of Visualizations?\n",
    "created" : 1430362213801.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2400342786",
    "id" : "3BF32A85",
    "lastKnownWriteTime" : 1430430044,
    "path" : "~/Code/ggvis-intro/ggvis-Tutorial.Rmd",
    "project_path" : "ggvis-Tutorial.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}